import 'package:excel/excel.dart';
import 'dart:io';

import 'package:flutter_count_track/features/order_management/data/models/order.dart';
import 'package:flutter_count_track/features/order_management/data/models/order_item.dart';
import 'package:flutter_count_track/core/database/app_database.dart'
    as db; // For OrderStatus
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Import Riverpod

// Helper class to hold imported order data along with customer product codes
class ExcelOrderImportData {
  final Order order;
  final List<OrderItem> items;
  final List<String> customerProductCodes; // To be used for mapping productId

  ExcelOrderImportData({
    required this.order,
    required this.items,
    required this.customerProductCodes,
  });
}

// Provider for the ExcelImportService
final excelImportServiceProvider = Provider<ExcelImportService>((ref) {
  return ExcelImportService();
});

class ExcelImportService {
  // Returns a list of ExcelOrderImportData objects
  Future<List<ExcelOrderImportData>> importOrdersFromExcel(
      String filePath) async {
    final Map<String, Order> ordersMap = {}; // orderCode -> Order
    final Map<Order, List<OrderItem>> itemsPerOrder = {};
    final Map<Order, List<String>> customerCodesPerOrder = {};
    final List<ExcelOrderImportData> resultList = [];

    try {
      var bytes = File(filePath).readAsBytesSync();
      var excel = Excel.decodeBytes(bytes);
      var sheetName = excel.tables.keys.first;
      var table = excel.tables[sheetName];

      if (table == null) {
        throw Exception("Seçilen Excel dosyasında veri sayfası bulunamadı.");
      }

      for (var i = 1; i < table.rows.length; i++) {
        // Start from 1 to skip header
        final row = table.rows[i];

        // Assuming columns: A=OrderCode, B=CustomerName, C=CustomerProductCode, D=Quantity
        final orderCode = row[0]?.value?.toString().trim() ?? '';
        final customerName = row[1]?.value?.toString().trim() ?? '';
        final customerProductCode = row[2]?.value?.toString().trim() ??
            ''; // Will be used for mapping later
        final quantityString = row[3]?.value?.toString().trim() ?? '';
        final quantity = int.tryParse(quantityString);

        if (orderCode.isNotEmpty &&
            customerProductCode.isNotEmpty &&
            quantity != null &&
            quantity > 0) {
          Order currentOrder = ordersMap.putIfAbsent(orderCode, () {
            final tempOrder = Order(
              id: 0, // Placeholder, will be auto-generated by DB
              orderCode: orderCode,
              customerName:
                  customerName.isNotEmpty ? customerName : 'Bilinmeyen Müşteri',
              status: db.OrderStatus.pending, // Default status
              createdAt: DateTime.now(),
              updatedAt: DateTime.now(),
            );
            itemsPerOrder[tempOrder] = [];
            customerCodesPerOrder[tempOrder] = [];
            return tempOrder;
          });

          final orderItem = OrderItem(
            id: 0, // Placeholder, will be auto-generated by DB
            orderId: 0, // Placeholder, will be linked to Order ID from DB
            productId:
                0, // Placeholder, will be resolved via ProductCodeMapping
            quantity: quantity,
            scannedQuantity: 0, // Initially 0
          );

          itemsPerOrder[currentOrder]?.add(orderItem);
          customerCodesPerOrder[currentOrder]
              ?.add(customerProductCode); // Store customerProductCode
        } else {
          print('Hatalı veya eksik satır atlandı (Satır ${i + 1}): $row');
          // Optionally, collect these errors to show to the user
        }
      }

      // Construct the result list
      ordersMap.forEach((_, order) {
        if (itemsPerOrder.containsKey(order) &&
            customerCodesPerOrder.containsKey(order)) {
          resultList.add(ExcelOrderImportData(
            order: order,
            items: itemsPerOrder[order]!,
            customerProductCodes: customerCodesPerOrder[order]!,
          ));
        }
      });

      return resultList;
    } catch (e) {
      print('Excel okuma sırasında hata: $e');
      throw Exception("Excel dosyası işlenirken bir hata oluştu: $e");
    }
  }
}
